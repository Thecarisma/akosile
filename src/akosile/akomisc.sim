#
call "simple/utilities/Console.sim"

printVerbose = false
akoBeSilent = false
akoDocAuthor = "Akosile Documentor"
akoDocDate = date()
akoDocTime = time()
akoDocLicense = "NONE" #to fetch all from .ako file

akoDestDir = null
templateName = "default"

variableMap = []
supportedSources = [".sim"]
allAkoDocLinks = [
	:currentDir = "./"
]
allAkoDocData = [
	[
		:title = "default"
	]
]


block printAkoMessage(message,type)
	if akoBeSilent { return } 
	if printVerbose and (type == 0 or type == 2 ) {
		if type == 2 {
			printWithFG(ConsoleColor.DARKYELLOW(), "akosile.warning	: ") @message
		else
			printWithFG(ConsoleColor.DARKMAGENTA(), "akosile.message	: ") @message
		}
		
	elif type == 1
		printWithFG(ConsoleColor.DARKCYAN(), "akosile.info	: ") @message
	}
	
	
block printAkoError(message)
	printWithFG(ConsoleColor.DARKRED(), "error.akosile	: ") @message+". stopping documentation..."
	exit(0)
	
block helpMessage()
	@"Helping"
	exit(0)
	
block aboutAkosile()
	@"It is a docu,emtation progra,"
	exit(0)
	
block throwAkoError(message,line,fileName)
	printWithFG(ConsoleColor.DARKRED(), "error.akosile	: ") @message
	println("                  In Line "+line+" in file "+fileName)
	exit(0)
	
block getRelativeLink(tempLink)
	ftempLink = ""
	splited = splitString(tempLink,'/')
	splitedLen = lengthOf(splited)
	for a = 0 to splitedLen - 1 {
		if splited[a] == '.' {
			ftempLink += "./"
		else
			ftempLink += "../"
		}
	}
	return ftempLink
	
block formatHTMLComment(rawComment)
	finalHtml = ""
	TOKEN_DEFAULT = 1 TOKEN_CODE = 2
	TOKEN_TYPE = TOKEN_DEFAULT
	
	pendingCloseDiv = false
	
	rawCommentLen = lengthOf(rawComment)
	for a = 0 to rawCommentLen {
		switch TOKEN_TYPE {
		case TOKEN_DEFAULT
			if rawComment[a] == "@" { 
				a++
				if (rawCommentLen - a) > 5 {
					token = toLowerCase(rawComment[a]+rawComment[a+1]+rawComment[a+2]+rawComment[a+3])
					if token = "retu" {
						a = absorbTillWhiteSpace(rawComment,a,"return")
						if toLowerCase(rawComment[a]) == "s" { a++ }
						
						if pendingCloseDiv { finalHtml += '</div>' pendingCloseDiv = false }
						finalHtml += '<div class="block-quote block-quote-info">Returns: <br />&emsp;&emsp;'
						pendingCloseDiv = true continue
						
					elif token = "data"
						a = absorbTillWhiteSpace(rawComment,a,"datatype")
						if toLowerCase(rawComment[a]) == "s" { a++ }
						finalHtml += ' - '
						continue
						
					elif token = "note"
						a = absorbTillWhiteSpace(rawComment,a,"note")
						if toLowerCase(rawComment[a]) == "s" { a++ }
						
						if pendingCloseDiv { finalHtml += '</div>' pendingCloseDiv = false }
						finalHtml += '<div class="block-quote block-quote-danger">Note: <br />&emsp;&emsp;'
						pendingCloseDiv = true continue
						
					elif token = "bxloc" #not currently treating @blockquote 
						a = absorbTillWhiteSpace(rawComment,a,"blockquote")
						if toLowerCase(rawComment[a]) == "s" { a++ }
						
						if pendingCloseDiv { finalHtml += '</div>' pendingCloseDiv = false }
						finalHtml += '<div class="block-quote block-quote-warning">'
						pendingCloseDiv = true continue
						
					elif token = "code" 
						a = absorbTillWhiteSpace(rawComment,a,"code")
						if toLowerCase(rawComment[a]) == "s" { a++ }
						
						if pendingCloseDiv { finalHtml += '</div>' pendingCloseDiv = false }
						finalHtml += '```simple '+nl TOKEN_TYPE = TOKEN_CODE continue
						
					elif toLowerCase(rawComment[a]+rawComment[a+1]+rawComment[a+2]) == "end"
						a = absorbTillWhiteSpace(rawComment,a,"end")
						if toLowerCase(rawComment[a]) == "s" { a++ }
						finalHtml += '</div>' pendingCloseDiv = false 
					}
				}
			} 
			finalHtml += rawComment[a]
		case TOKEN_CODE 
			if (rawCommentLen - a) > 3 {
				if toLowerCase(rawComment[a]+rawComment[a+1]+rawComment[a+2]+rawComment[a+3]) == "@end" {
					a = absorbTillWhiteSpace(rawComment,a,"@end")
					finalHtml += '``` '+nl TOKEN_TYPE = TOKEN_DEFAULT @finalHtml continue
				}
			}
			finalHtml += rawComment[a]
		}
	}
	return finalHtml

block absorbTillWhiteSpace(source,i,val)
	l = lengthOf(val)
	for d = 0 to l { i++ } 
	return absorbWhiteSpace(source,i)

block absorbWhiteSpace(source,i)
	while isWhiteSpace(source[i+1]) { i++ }
	return i
